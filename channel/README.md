# Channels
## Via Jon Gjengset's Crust of Rust: Channels
- Channels are a way to send information from one place to another
- `std::sync::mpsc` - Multi Producer Single Consumer -> Many senders, one receiver
- Receiver type, Sender type, SyncSender type
- Channels are uni-directional, only senders can send and only receivers can receive
- You can clone the sender but not the receiver
- Sender and Receiver are parameterized by the type of the thing they are going to send and receive
- You can construct a channel and send stuff that isn't Send as long as the sender and receiver are not moved across the thread boundary
- Can send any type on the channel, it's not serialization, not TCP
- T has to be sized
- Example: One thread is an Event loop and it might send to itself 
- The Channel owns the T
- **Backpressure** is the resistance or flow opposing flow of data through software. Reading is faster than writing, so if you have to do both at the same time, you can't pay off that debt until after you finished reading. It can occur when one server is sending requests faster than one server can process them. Another example is sending information to the DOM is cheaper than actually rendering the information. So on the client side, information needs to be buffer or dropped. Three main strategies: control the producer, buffer by accumulating data spikes, or drop some of the data. Source: https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7
- **Mutex**: Mutual exclusion, you have a `lock` method, which returns a `guard`, and while you have that guard you are guaranteed to be the only thing that can access the T protected in the mutex. If two threads try to lock the same mutex, one will get to go and the other will block (aka wait) til the other released the `guard` at which point it can go. This ensures only one thread modifying the T at any point in time.
- Mutex returns **LockResult**. Imagine the last thread to take the lock panicked while holding the lock. That might mean the data under the lock is in an inconsistent state. The way the lock communicates this is when the thread panics it releases the lock but sets a flag in it to say the last thing that accessed this panicked. Thus, a LockResult is either a `Guard` or a `PoisonError<Guard>`. 
- **Arc**: A reference count type (Atomically Reference Counted type), which means it can be used across thread boundaries. Arc is needed because otherwise the Sender and Receiver would have two different instances of Inner. And if they did, how would they communicate? They need to share an inner because that's where the sender is going to put data and where the receiver is going to take data out of.
- **Condvar**: Conditional variable is a way to announce to a different thread you've changed something it cares about. E.g. a receiver is sleeping till it receives something, the sender has to wake up the thread that's sleeping to inform it that there's information for it to read. 
- A mutex is like a boolean semaphore (a boolean flag you check and atomically update). If the flag is set and something else is in the critical section and has the mutex, with a boolean semaphore you have to spin and repeatedly check to see it. With a mutex, the OS can put the thread to sleep and wake it back up when the mutex becomes available.
- The problem of course with using a `Vector` as a queue is that removing elements from the beginning results in having to shift all the elements over to fill the hole that was removed, so a better alternative is a `RingBuffer`. Rust also has `VecDeque` which is sort of like a vector but stores start and end position seperately. So if you pop from the beginning, it just moves the pointer to where the data starts. The data might end up wrapping around but it can be used as a queue rather than a stack.
- Blocking version of Receive: Provide a receive whereby if there isn't something yet, it waits for something to be in the channel.
- `Condvar` needs to be outside the `mutex`, because a thread is holding the mutex and you need to wake another thread up. The person you wake up has to take the mutex but because you're holding the mutex they'll go back to sleep because you're still holding it. After you finish, no thread is awake causing a **deadlock.** `Condvar` is let go at the same time you notify the other thread.
- With `Condvar` requires an input of a mutex guard, so that you prove you own the lock and it'll make sure it does the step as an `atomic` step.
- `atomic` actions that happen all at once. It either happens completely or nothing happens at all. No side effects are noticeable until the action is complete. No other process can interfere with the manipulation of data by an atomic action. 
- `wait` gives a mutex guard back. If you get woken up, you automatically get handed the mutex. Thus, to use wait, you must pass in a guard. On a `condvar`  
- Async/Await is generally when you are I/O bound not CPU bound
- `notify_one()` does not guarantee which thread will be woken up
- `Arc::strong_count(self)` gives how many references there are to that arc. 
- Generally shouldn't wake up threads unless you need to (related to performance rather than correctness)